<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Logan Brassington">
<meta name="dcterms.date" content="2024-03-01">
<meta name="description" content="Can ChatGPT solve puzzles?">

<title>More Puzzles – My Explorations with LLMs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-8647a4a42273f773479d27c00df3f9ed.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Explorations with LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">More Puzzles</h1>
                  <div>
        <div class="description">
          Can ChatGPT solve puzzles?
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">LLMs</div>
                <div class="quarto-category">Models</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Logan Brassington </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 1, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="more-puzzles" class="level2">
<h2 class="anchored" data-anchor-id="more-puzzles">More Puzzles</h2>
<p>In a previous blog post I explored how Chat GPT did with a couple of riddles and puzzles from :https://puzzlewocky.com/brain-teasers/classic-short-brain-teasers-and-riddles/. Having always loved puzzles - I thought it would be interesting to explore this a bit more.</p>
<p>It is interesting to observe what types of puzzles GPT is able to handle well and what types it can’t.</p>
<section id="davids-father" class="level3">
<h3 class="anchored" data-anchor-id="davids-father">David’s Father:</h3>
<p><strong>Question:</strong> David’s father has three sons: Snap, Crackle, and ________?</p>
<p><strong>GPT Response:</strong> David!</p>
<p><strong>Answer:</strong> David.</p>
<p><strong>Analysis:</strong> GPT got it right - we can try some harder ones.</p>
</section>
<section id="apples-and-oranges" class="level3">
<h3 class="anchored" data-anchor-id="apples-and-oranges">Apples and Oranges:</h3>
<p><strong>Question:</strong> George shows Vincent three closed boxes. One contains only apples, one contains only oranges, and one contains a mix of apples and oranges. The boxes are labeled Apples, Oranges, and Mixed, but George says all of the boxes are labeled incorrectly. Vincent is allowed to choose one box and pick one piece of fruit from it at random. He does so and is able to correctly identify all three boxes. How did he do it?</p>
<p><strong>GPT Response:</strong> Vincent knows that all the labels are incorrect, so he can use logic to deduce the correct labels. Here’s how he does it:</p>
<p>Choose the “Mixed” box: Since every label is wrong, the box labeled “Mixed” cannot actually contain both apples and oranges—it must contain only apples or only oranges.</p>
<p>Pick a fruit from the “Mixed” box: Suppose Vincent picks an apple. That means this box only contains apples (because it cannot be mixed).</p>
<p>Relabel the boxes logically:</p>
<p>The box labeled “Apples” cannot contain only apples (since its label is wrong). It must contain either only oranges or the mixed fruit. The box labeled “Oranges” cannot contain only oranges (since its label is wrong). It must contain either only apples or the mixed fruit.</p>
<p>Since we now know the “Mixed” box actually contains only apples, the box labeled “Oranges” must be the mixed box (because it cannot actually be oranges-only).</p>
<p>That leaves the box labeled “Apples,” which must actually contain only oranges.</p>
<p>Final Box Assignments: The “Mixed” box (incorrectly labeled) actually contains only apples. The “Oranges” box (incorrectly labeled) actually contains both apples and oranges. The “Apples” box (incorrectly labeled) actually contains only oranges. By picking just one fruit, Vincent was able to deduce the correct labeling of all the boxes!</p>
<p><strong>Answer:</strong> Vincent chooses a fruit from the box labeled Mixed. He knows this box is labeled incorrectly, so the box must actually contain either all apples or all oranges. If he pulls out an apple, then that must be the box of all apples. Since the other two boxes are labeled Apples and Oranges, and they are both labeled incorrectly, the box of all oranges must be labeled Apples. That means the box labeled Oranges contains mixed fruit.</p>
<p>If he pulls out an orange, then that must be the box of all oranges. Since the other two boxes are labeled Apples and Oranges, and they are both labeled incorrectly, the box of all apples must be labeled Oranges. That means the box labeled Apples contains mixed fruit.</p>
<p><strong>Analysis:</strong> GPT again gave the correct assessment in a concise way - I think that it was able to break down the problem into a clear concise way to approach the problem.</p>
</section>
<section id="the-stopped-clock" class="level3">
<h3 class="anchored" data-anchor-id="the-stopped-clock">The Stopped Clock:</h3>
<p><strong>Question:</strong> Erika forgot to wind the clock on her wall, so it has stopped, and that is her only timepiece. She walks to a friend’s house to visit, observing the correct time on her friend’s clock while she is there, and then walks home. When she gets home she makes a simple calculation and then sets her clock to the correct time, despite not knowing how long it took her to walk home from her friend’s house. How did she do it?</p>
<p><strong>GPT Response:</strong> Erika uses a clever trick to determine the correct time without knowing her exact walking duration. Here’s how she does it:</p>
<ol type="1">
<li><p><strong>Note the stopped clock’s time</strong> before leaving her house.</p></li>
<li><p><strong>Walk to her friend’s house</strong> and check the correct time on her friend’s clock upon arrival.</p></li>
<li><p><strong>Spend some time at her friend’s house</strong> and check the correct time again just before leaving.</p></li>
<li><p><strong>Walk home</strong> and look at the time on the stopped clock upon arrival.</p></li>
<li><p><strong>Calculate the correct time using symmetry</strong>:</p>
<ul>
<li>Let’s say when she left home, the stopped clock showed <strong>X</strong>.</li>
<li>When she arrived at her friend’s house, the correct time was <strong>A</strong>.</li>
<li>When she left her friend’s house, the correct time was <strong>B</strong>.</li>
<li>When she got home, the stopped clock still showed <strong>X</strong>.</li>
</ul></li>
</ol>
<p>Since her walk to and from her friend’s house likely took the same amount of time, the correct time upon her arrival home is the midpoint between <strong>A</strong> and <strong>B</strong>:</p>
<p>[ = B + ]</p>
<p>By setting her clock to that calculated time, she correctly resets it!</p>
<p><strong>Answer:</strong> Before she left her house, Erika wound her clock and set it to 12 o’clock. Therefore, when she returned, she could easily see the total amount of time she had been gone. At her friend’s house, she noted the time when she arrived and when she left, so she knows the amount of time she spent at her friend’s house. She subtracts that from the total time she was gone and divides by two. That is her one-way travel time from her friend’s house, which she adds to the time that was showing on her friend’s clock when she left her friend’s house.</p>
<p><strong>Analysis:</strong> Again there was a logical thought process - ChatGPT was able to talk through the problem through to the correct answer.</p>
</section>
<section id="a-bat-and-a-ball" class="level3">
<h3 class="anchored" data-anchor-id="a-bat-and-a-ball">A Bat and a Ball:</h3>
<p><strong>Question:</strong> A bat and a ball cost $1.10 together. The bat costs $1 more than the ball. How much does the ball cost?</p>
<p><strong>GPT Response:</strong> Let the cost of the ball be <strong>x</strong> dollars.<br>
Since the bat costs <strong>$1 more</strong> than the ball, the bat’s cost is <strong>x + 1</strong> dollars.</p>
<p>Together, they cost <strong>$1.10</strong>, so we set up the equation:</p>
<p>[ x + (x + 1) = 1.10 ]</p>
<p>Simplify:</p>
<p>[ 2x + 1 = 1.10 ]</p>
<p>Subtract <strong>1</strong> from both sides:</p>
<p>[ 2x = 0.10 ]</p>
<p>Divide by <strong>2</strong>:</p>
<p>[ x = 0.05 ]</p>
<p>So, the <strong>ball costs $0.05 (5 cents)</strong>, and the bat costs <strong>$1.05 (1 dollar and 5 cents)</strong>, which correctly adds up to <strong>$1.10</strong>.</p>
<p><strong>Answer:</strong> The ball costs 5 cents. The bat costs $1.05. Many people answer too quickly and say that the ball costs 10 cents. However, if that were true, and the bat costs $1 more than the ball, then the bat would have to cost $1.10, making the total cost $1.20.</p>
<p><strong>Analysis:</strong> Here it was interesting to see that ChatGPT took an algebraic approach - that is to say one where it treated the problem like a Math word problem (which it was).</p>
</section>
<section id="a-unique-state-name" class="level3">
<h3 class="anchored" data-anchor-id="a-unique-state-name">A Unique State Name:</h3>
<p><strong>Question:</strong> What is unique about the word Alaska?</p>
<p><strong>GPT Response:</strong> The word <strong>“Alaska”</strong> has several unique features:</p>
<ol type="1">
<li><strong>Only U.S. state name with three vowels at the start</strong> – It starts with <strong>A-L-A</strong>, three vowels in a row.<br>
</li>
<li><strong>Symmetry in letters</strong> – The structure <strong>A-L-A-S-K-A</strong> has a balanced, almost palindrome-like appearance.<br>
</li>
<li><strong>Single continuous sound</strong> – When spoken, it flows smoothly without abrupt breaks.<br>
</li>
<li><strong>Derived from an Indigenous word</strong> – It comes from the Aleut word <em>Alyeska</em>, meaning “great land.”<br>
</li>
<li><strong>Contains no repeated consonants</strong> – Even though “A” appears three times, all consonants (L, S, K) are unique.</li>
</ol>
<p>It’s a visually and phonetically interesting word!</p>
<p><strong>Answer:</strong> It is the only state name that can be typed using just one row of keys on a keyboard.</p>
<p><strong>Analysis:</strong> Here GPT got the question wrong and clearly was grasping at straws. That being said there seemed to be a bit of logic in the sense that ackowledging the AKA and trying to break down the letter structure was definitley in the right direction. I think that the hard part about this question was there were was not straight forward and did not provide the needed context. This is indicative of the types of abstract problems that GPT may have issues solving in the future.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/logbrass\.github\.io\/comm4190_S25_Using_LLMs_Blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>